# 队列

## 队列的定义

队列是一种抽象的数据结构, 有点类似于栈。与栈不同, 队列的两端都是开放的。 一端始终用于插入数据(入队), 另一端用于移除数据(出队)。 队列遵循先进先出的方法, 即先存储的数据项将首先被访问。

事实上, 生活中有很多这样的例子, 如大家排队购物、排队等公交、排队等电梯、排队买饭等, 都是先排
队的人先离开队列。

## 队列示例

队列的真实示例可以是单车道单行道, 车辆先进入, 先离开。

![图4-1](./assets/4-1.png)

队列表示: 正如我们现在所了解的那样, 在队列中, 我们出于不同的原因访问两端。 下面给出的下图试图将队列表示解释为数据结构

![图4-1](./assets/4-2.png)

与堆栈一样, 队列也可以使用数组、链表、指针和结构来实现。

## 队列的基本概念

队列(Queue)：一种先进先出(First In First Out , FIFO)的线性表, 即只允许在表的一端进行插人,而在另一端进行删除。所以, 队列也是一种运算受限的线性表.

## 队列的基本操作和性质

队列的性质：先进先出。为了实现先进先出, 我们要设置两个指针：第一个是队首,即允许进行删除的一端, 一般用firont 表示;第二个是队尾, 即允许进行插人的一端, 一般用 rear 表示。

### 队列有两种最基木的操作

+ 出队: 也就是删除队首元素。

+ 入队: 也就是在队尾插人新元素。

在空队列中依次加入元素a1, a2, ……, a之n后, a1是队首元素, an 是队尾元素。出队就a1-an的顺序出队, 人队需要在an后依次插人元素。

## 队列的功能

+ enqueue() − 添加(存储)一个项目到队列中。
+ dequeue() − 从队列中删除(访问)一个项目。
+ peek() - 获取队列前面的元素而不删除它。
+ isfull() - 检查队列是否已满。
+ isempty() - 检查队列是否为空。

## 顺序队列

以列可以用顺序结构和链式结构进行存储, 我们首先看顺序结构, 利用一组连线的存储单元(一维数组)依次存放从队首到队尾的各个元素,称为顺序队列。队列和顺序栈类似, 也有动态和静态之分．我们接下来要学习的是静态顺序队列。大家知道, 队列有队首和队尾,所以顺序队列中要定义队首和队尾。

### 顺序队列的初始化

为了方便说明, 在下图中,数组的大小设置为10,也就是下标是0~9,元素是$ a_1、a_2 、a_3 、a_4 、a_5、a_6、a_7、a_8 、a_9 $ 

<img src="./assets/4-4.png" style="zoom:150%;" />  

+ 顺序队列初始化时, 队列是空的, 数组的下标是0-9此时 front 和rear均指向下标为0的位置, 如图(a)所示。

  当队列不空时, front 指向队首元素, rear 指向队尾元素的下一个空位置, 如图 b)所示。队列中有4个元素 $a1、a2、a3、a4$, 此时 front 指向队首元素 a1,rear 指向队尾元素$a_4$的下一个空位置。

+ 入队操作。先放入元素, 再rear++。(C)所示, 先将$a_5$放入到下标为4的位置, 也就是Queue_array[rear], rear从4->5。
+ 出队操作。先出元素, 再front++。如图 c所示, 此时front 是0, 先取出下标为 front 的元素, 也就是 Queve_ array[front], 再front++, front 变为1。此时, 细心的小伙伴会发现, 在图d中, 元素出队了, 后面的元素没有往前补缺, 而我们平时排队中, 如果前面的人离开了, 后面的人就会自动往前移动。这是怎么回事呢？这里的存储结构是顺序结构, 如果依次将后续的元素向前移动, 那么这个操作的复杂度就太高了, 得不偿失。于是, 元素出队了,front 指针向后移动, 而不是将后续的元素向前移动, 毕竟front 向后移动只需要加1就可以了。
+ 队列空的条件。我们在前面挖了一个坑(front 指向队首元素,rear指向队尾元素的下一个空位置), 在讲解队列为空之前, 我们先看几个队列空的例子。如图(a)、(b)、(C)所示, 可以看到, 当front == rear时, 表示队列为空。如因(d)所示, front 指向队首元素日, rear 指向队尾元素 as。如果依次把 a1、a2、a3、a4出队列, 那么front 和rear将同时指向4, 如图(e)所示, 此时 front ==rear, 而队列中还有元素, 这就和front-rear 表示队列为空无法区分了。因此设置 front 指向队首元素,rear 指向队尾元素的下一个空位置, 当 front == rear时,表示队列为空。

### 顺序队列的编码

#### 定义队列的基本结构

```c
typedef struct SqQueue{
	ElemType data[Maxsize]; //用静态数组存放队列元素
	int front, rear; //队头指针与队尾指针
}SqQueue;
```
#### 初始化队列

```c
void InitQueue(SqQueue& Q)
{//初试时，队头、队尾指针指向0
	Q.front = Q.rear = 0;
}
```

#### 判断队列空

如果队列首指针等于尾指针，那么该队列没有元素

```c
int QueueEmpty(SqQueue Q)
{
	if (Q.rear == Q.front)
		return 1;
	else
		return 0;
}
```
#### 入队

```c
int EnQueue(SqQueue& Q, ElemType x)
{
	if (Q.rear == Maxsize) //会存在假上溢
		return 0;//队满则报错
	Q.data[Q.rear] = x; //将x插入队尾
	Q.rear++;
	return 1;
}
```
#### 出队

```c
intt DeQueue(SqQueue& Q, ElemType& x)
{
	if (Q.front == Q.rear)
		return 0; //队空则报错
	x = Q.data[Q.front]; //将队头元素赋给x
	Q.front++;
	return 1;
}
```

## 循环队列

为充分利用向量空间, 克服"假溢出"现象的方法是：将向量空间想象为一个首尾相接的圆环, 并称这种向量为循环向量。存储在其中的队列称为循环队列(Circular Queue)。循环队列是把顺序队列首尾相连, 把存储队列元素的表从逻辑上看成一个环, 成为循环队列。

如图:  

![图4-1](./assets/4-33.png)



## 循环队列的特点和操作

循环队列就是将队列存储空间的最后一个位置绕到第一个位置, 形成逻辑上的环状空间, 供队列循环使用。在循环队列结构中, 当存储空间的最后一个位置已被使用而再要进入队运算时, 只需要存储空间的第一个位置空闲, 便可将元素加入到第一个位置, 即将存储空间的第一个位置作为队尾。循环队列可以更简单防止**伪溢出**（假溢出）的发生, 但队列大小是固定的。 

在循环队列中, 当队列为空时, 有front=rear, 而当所有队列空间全占满时, 也有front=rear。为了区别这两种情况, 规定循环队列最多只能有MaxSize-1个队列元素, 当循环队列中只剩下一个空存储单元时, 队列就已经满了。因此, 队列判空的条件是front=rear, 而队列判满的条件是front=(rear+1)%MaxSize。

队列判空、判满

+ 牺牲结点法

  实现方式：尾指针 rear 指向尾结点的下一个结点

  初始化： rear=front=0

  队空：  Q.rear==Q.front t ==0

  尾指针与头指针重合队满： (Q.rear+r+1) % MaxSize == Q.front t 尾指针的下一个位置是队头

  队列中元素个数 = (rear+MaxSize-front) % MaxSize
  
+ 增加辅助变量 01

  设置 size实现方式：在结构体中加入变量 size，用于记录队列长度。 

  入队成功时 size++，出队成功时 size--

  初始化： rear=r=front=0; size=0;

  队空：  size == 0队满：  size == MaxSize

+  增加辅助变量 02设置 tag实现方式：在结构体中加入变量 tag，用于记录上一次进行的操作是出队还是入队。 

   入队成功时，tag=1；

   出队成功时，tag=0。
   
   初始化：rear=r=front=0; tag=0;
   
   队空：front\==rear && tag==0
   
   队满： front\==rear && tag==1

## 循环队列的要点

循环队列即是逻辑结构也是存储结构, 只能由数组实现, 不能用链表实现。![loop_queeue](./assets/loop_queeue.png)

### 循环队列条件处理

循环队列中, 由于入队时尾指针向前追赶头指针, 出队时头指针向前追赶尾指针, 造成队空和队满时头尾指针均相等。因此, 无法通过条件front==rear来判别队列是「空」还是「满」。
解决这个问题的方法至少有两种：  

1. 另设一布尔变量以区别队列的空和满；
3. 另一种方式就是数据结构常用的： 队满时：(rear+1)%n==front, n为队列长度(所用数组大小), 由于rear, front均为所用空间的指针, 循环只是逻辑上的循环, 所以需要求余运算。如图1所示情况, 队已满, 但是rear(5)+1=6！=front(0), 对空间长度求余, 作用就在此6%6=0=front(0)。

![图4-1](./assets/4-3.png)

类型定义采用环状模型来实现队列,各数据成员的意义如下：
+ front指定队首位置, 删除一个元素就将front顺时针移动一位
+ rear指向元素要插入的位置, 插入一个元素就将rear顺时针移动一位
+ count存放队列中元素的个数, 当count等于MaxQSize时, 不可再向队列中插入元素

## 双端队列
是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出, 其限定插入和删除操作在表的两端进行。
双端队列是限定插入和删除操作在表的两端进行的线性表。这两端分别称做端点1和端点2。也可像栈一样, 可以用一个铁道转轨网络来比喻双端队列。在实际使用中, 还可以有输出受限的双端队列(即一个端点允许插入和删除, 另一个端点只允许插入的双端队列)和输入受限的双端队列(即一个端点允许插入和删除, 另一个端点只允许删除的双端队列)。而如果限定双端队列从某个端点插入的元素只能从该端点删除, 则该双端队列就蜕变为两个栈底相邻的栈了。

### 双端队列优缺点

尽管双端队列看起来似乎比栈和队列更灵活, 但实际上在应用程序中远不及栈和队列有用。因为我们在用某些数据结构的时候，首先想起来的永远是比较经典，有个性的数据结构，而不是万金油。所以啊，太过于圆滑反而会失去自我。                      



## 链式队列

简称「链队列」，即使用链表实现的队列存储结构。

链式队列的实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如下图所示:

| ![链式队列的初始状态](./assets/1I53960V-0.gif) |
| :--------------------------------------------: |
|           图 4-11 链式队列的初始状态           |

图 4-11所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。

在创建链式队列时，强烈建议初学者创建一个带有头节点的链表，这样实现链式队列会更简单。

由此，我们可以编写出创建链式队列的 C 语言实现代码为:

```c
//链表中的节点结构
typedef struct QNode{    
	int data;    
  struct QNode * next;
}QNode;
//创建链式队列的函数
QNode * initQueue(){    
//创建一个头节点    
QNode * queue=(QNode*)malloc(sizeof(QNode));    
  //对头节点进行初始化    
  queue->next=NULL;    
  return queue;
}
```

## 链式队列数据入队

链队队列中，当有新的数据元素入队，只需进行以下 3 步操作：

1. 将该数据元素用节点包裹，例如新节点名称为 elem；
2. 与 rear 指针指向的节点建立逻辑关系，即执行 rear->next=elem；
3. 最后移动 rear 指针指向该新节点，即 rear=elem；

由此，新节点就入队成功了。

例如，在图 1 的基础上，我们依次将 `{1,2,3}` 依次入队，各个数据元素入队的过程如图 2 所示:

![{1,2,3} 入链式队列](./assets/1I5396159-1.gif)

 {1,2,3} 入链式队列

数据元素入链式队列的 C 语言实现代码为：

```c
QNode* enQueue(QNode * rear,int data){    
//1、用节点包裹入队元素    
	QNode * enElem=(QNode*)malloc(sizeof(QNode));    
  enElem->data=data;    
  enElem->next=NULL;    
  //2、新节点与rear节点建立逻辑关系    
  rear->next=enElem;    
  //3、rear指向新节点    
  rear=enElem;    
  //返回新的rear，为后续新元素入队做准备    
  return rear;
}
```

## 链式队列数据出队

当链式队列中，有数据元素需要出队时，按照 「先进先出」的原则，只需将存储该数据的节点以及它之前入队的元素节点按照原则依次出队即可。这里，我们先学习如何将队头元素出队。

链式队列中队头元素出队，需要做以下 3 步操作：

1. 通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；
2. 将 p 节点（即要出队的队头节点）从链表中摘除；
3. 释放节点 p，回收其所占的内存空间；

例如，在图b) 的基础上，我们将元素 1 和 2 出队，则操作过程如图 4-3 所示：

| ![链式队列中数据元素出队](./assets/1I5394232-2.gif) |
| :-------------------------------------------------: |
|            图 4-3 链式队列中数据元素出队            |

链式队列中队头元素出队的 C 语言实现代码为：

```c
void DeQueue(QNode * top,QNode * rear){    
	if (top->next==NULL) {        
		printf("队列为空");        
		return ;    
	}    
// 1、    
	QNode * p=top->next;    
	printf("%d",p->data);    
	top->next=p->next;    
	if (rear==p) {       
		rear=top;    
	}    
	free(p);
}
```

注意，将队头元素做出队操作时，需提前判断队列中是否还有元素，如果没有，要提示用户无法做出队操作，保证程序的健壮性。

## 总结

通过学习链式队列最基本的数据入队和出队操作，我们可以就实际问题，对以上代码做适当的修改。

前面在学习顺序队列时，由于顺序表的局限性，我们在顺序队列中实现数据入队和出队的基础上，又对实现代码做了改进，令其能够充分利用数组中的空间。链式队列就不需要考虑空间利用的问题，因为链式队列本身就是实时申请空间。因此，这可以算作是链式队列相比顺序队列的一个优势。

这里给出链式队列入队和出队的完整 C 语言代码为：

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct QNode {
	int data;
	struct QNode * next;
}QNode;
QNode * initQueue() {
	QNode * queue=(QNode*)malloc(sizeof(QNode));
	queue->next=NULL;
	return queue;
}
QNode* enQueue(QNode * rear,int data) {
	QNode * enElem=(QNode*)malloc(sizeof(QNode));
	enElem->data=data;
	enElem->next=NULL;
	//使用尾插法向链队列中添加数据元素    
	rear->next=enElem;
	rear=enElem;
	return rear;
}
QNode* DeQueue(QNode * top,QNode * rear) {
	if (top->next==NULL) {
		printf("\n队列为空");
		return rear;
	}
	QNode * p=top->next;
	printf("%d ",p->data);
	top->next=p->next;
	if (rear==p) {
		rear=top;
	}
	free(p);
	return rear;
}
int main() {
	QNode * queue,*top,*rear;
	queue=top=rear=initQueue();
	//创建头结点     
	//向链队列中添加结点，使用尾插法添加的同时，队尾指针需要指向链表的最后一个元素    
	rear=enQueue(rear, 1);
	rear=enQueue(rear, 2);
	rear=enQueue(rear, 3);
	rear=enQueue(rear, 4);
	//入队完成，所有数据元素开始出队列    
	rear=DeQueue(top, rear);
	rear=DeQueue(top, rear);
	rear=DeQueue(top, rear);
	rear=DeQueue(top, rear);
	rear=DeQueue(top, rear);
	return 0;
}
```



## 队列的典型应用
1. 排队、打印服务
2. 树的层次遍历
3. 图的广度优先遍历
4. 优先队列


### 优先队列

普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。例如普通二叉堆，配对堆等。



## 课后习题及答案

### 选择题

1. 若进栈序列为a,b,c，则通过入出栈操作可能得到的a,b,c的不同排列个数为       

   A) 4         B) 5         C) 6         D) 7

   【答案】B。注意对栈为先进后出，可能序列为abc、bac、cba、acb、bca，共计5种。

2. 最不适合用作链式队列的链表是( )。
   A.只带队首指针的非循环双链表
   B.只带队首指针的循环双链表
   C.只带队尾指针的循环双链表
   D.只带队尾指针的循环单链表

   【答案】A。由于非循环双链表只带队首指针，在执行入队操作时需要修改队尾结点的指针域，而查找队尾结点需要0(n)的时间。B、C和D均可在0(1)的时间内找到队首和队尾。

3. 栈S最多能容纳4个元素。现在6个元素按A、B、C、D、E、F的顺序进栈，下列哪一个序列是不可能的出栈序列？

   A) A、B、C、D、E、F            B) A、F、E、D 、C、B

   C) C、B、E、D、A、F            D) C、D、B、F、 E、 A

   【答案】B。选项A，A进栈后出栈、B进栈后出栈、C进栈后出栈、D进栈后出栈、E进栈后出栈、F进栈后出栈，栈只使用了一个容量并可得到A选项所对应的结果。

   选项B，A进栈后出栈、B进栈、C进栈、D进栈、E进栈此时栈S满，F无法进栈，因此不可能出现该序列

   选项C，A进栈、B进栈、C进栈后出栈、B出栈、D进栈、E进栈后出栈、D出栈、A出栈、F进栈后出栈，得到C选项所对应的结果，并且栈所占最大容量为3符合题目要求。

   选项D，A进栈、B进栈、C进栈后出栈、D进栈后出栈、B出栈、E进栈、F进栈后出栈、E出栈、A出栈，得到D选项所对应的结果且栈所占最大容量为3符合题目要求。

4. 循环队列存储在数组A[0..m]中，则入队时的操作为（    ）。

   A. rear=rear+1				B. rear=(rear+1) mod (m-1)
   
   C. rear=(rear+1) mod m		D. rear=(rear+1) mod (m+1)
   
   【答案】D。注意数组A[0..m]共存储(m+1)个元素。

5. 若已知一个栈的入栈序列是1, 2, 3, …, n，其输出序列为p1, p2，p3，…，pn，若p1=n，则pi为 (      )

    A．i       B．n=i      C．n-i+1       D．不确定

   【答案】C。此题可使用特殊值法进行计算，如入栈序列为1, 2, 3, 4, 5, 6,7,8，其输出序列为p1, p2，p3，…，pn，则p1=8，p2=7，p3=6，p4=5，p5=4….按照此规律可得下标i与n的关系。

6. 设有一个递归算法如下：则计算 fact(n) 需要调用该函数的次数为（ ）。
```c
int fact(int n) { //n大于等于 0
   if(n<=0)    return 1;
   else      return n*fact(n-1);
 }
```
​         A.n+1        B. n-1      C. n          D. n+2

​       【答案】A。此题也适用特殊值法。设 n=0，易知仅调用一次 fact(n) 函数，故选 A 。

7. 为解决计算机主机与打印机间速度不匹配问题，通常设一个打印数据缓冲区。主机 将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是（ ）。

    A.队列      B .栈      C.线性表      D.有序

   【答案】A。本题为关于队列应用的经典题目，解决缓冲区问题应利用一种先进先出的线性表，而队列正是一种先进先出的线性表。而递归调用、函数调用、表达式求值均用到了栈的后进先出性质。

8. 用链接方式存储的队列，在进行删除运算时（ ）。

    A. 仅修改头指针                B. 仅修改尾指针

    C. 头、尾指针都要修改     D. 头、尾指针可能都要修改

   【答案】D。一般情况下只修改头指针，但是，当删除的是队列中最后一个元素时，队尾指针也会丢失，因此需对队尾指针重新赋值。

9. 最大容量为 n 的循环队列， 队尾指针是 rear ，队头是 front ，则队空的条件是 （ ）。

   A. $(rear+1)\%n==front$             B. $rear==front$

   C. $rear+1==front$                         D. $(rear-1)\%n == front $
   
   【答案】B。注意区分队空、队满判断条件。

10. 栈和队列具有相同的( ).

    A.抽象数据类型         B.逻辑结构       C.存储结构                D.运算

    【答案】B。栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同。因此其抽象数据类型也不相同。

11. 设链表不带头结点且所有操作均在表头进行，则下列最不适合作为链栈的是( )。

    A.只有表头结点指针，没有表尾指针的双向循环链表

    B.只有表尾结点指针，没有表头指针的双向循环链表

    C.只有表头结点指针，没有表尾指针的单向循环链表

    D.只有表尾结点指针，没有表头指针的单向循环链表

    【答案】C。对于双向循环链表，不管是表头指针还是表尾指针，都可以很方便地找到表头结点，方便在表头做插入或删除操作。而单循环链表通过尾指针可以很方便地找到表头结点，但通过头指针找尾结点则需要遍历一次链表。对于C,插入和删除结点后，找尾结点需要花费0(n)的时间。

12. 一个栈的输入序列为1,2,3..*,n, 输出序列的第一个元素是i,则第j个输出元素是( )。

    A. i-j- 1               B. i-j           C. j-i+ 1              D.不确定
    
    【答案】D。注意题目信息，不要与第5题混淆。当第i个元素第一个出栈时，则i之前的元素可以依次排在i之后出栈,但剩余的元素可以在此时进栈并且也会排在i之前的元素出栈，所以第j个出栈的元素是不确定的。

13. 若一个栈的输入序列是P1,P2.*.,Pn输出序列是1,2,3,.,n,若P3=1,则P1的值( ).

    A. .可能是2        B.一定是2      C.不可能是2      D.不可能是3
    
    【答案】C.入栈序列是P1,P2.*.,Pn。由于P3=1,即PI, P2, P.连续入栈后，第一个出栈元素是P3，说明P1,P2已经按序进栈,根据先进后出的特点可知，P2必定在P1之前出栈，而第二个出栈元素是2，而此时P1不是栈项元素，因此P1的值不可能是2。

14. 若已知一个栈的入栈序列是1, 2,3,4,其出栈序列为P,P2,P3,P4,则P2, P4不可能是( )。

     A.2,4       B. 2,1      C.4,3       D.3,4

    【答案】C。逐个判断每个选项可能的入栈出栈顺序。对于A选项,可能的顺序是1入，1出，2入，2出，3入，3出，4入，4出。对于B选项,可能的顺序是1入，2入，3入，3出，2出，4入, 4出，1出。对于D选项,可能的顺序是1入，1出，2入，3入，3出，2出，4入，4出。而C没有对应的序列。

15. 设栈的初始状态为空，当字符序列“n1_ ”作为栈的输入时，输出长度为3，且可用做C语言标识符的序列有()个。

    A.4    B. 5    C.3     D. 6

    【答案】C。首先，栈的顺序是先进后出字符序列为n3_   
    1)n入栈，再出栈，然后3入栈，再出栈，—入栈，再出栈   序列是n3_
    2)n入栈，再出栈,然后3,—入栈，再出栈，序列是n_3
    3)n入栈，3入栈，再出栈，n出栈， —入栈，再出栈   序列是3n_
    4)n入栈，3入栈，再出栈, —入栈,序列是3_n
    5)n入栈，3入栈,_入栈，序列是_3n

       其次，C语言的标识符不能以数字开头，去除3n_和3_n   答案为3

16. 采用共享栈的好处是( )。

    A.减少存取时间，降低发生上溢的可能    B.节省存储空间，降低发生上溢的可能

    C.减少存取时间，降低发生下溢的可能    D.节省存储空间，降低发生下溢的可能

    【答案】B. 存取栈中的元素都只需要0(1)的时间，所以减少存取时间无从谈起,排除A、C。另外，栈的插入和删除操作都是在栈顶进行的，只可能发生上溢(栈顶指针超出了最大范围)，而下溢是指当缓冲器空，还往外读。因此本题答案为B。

17. 已知循环队列的存储空间为数组A[21]，front 指向队头元案的前一一个位置，rear 指向队尾元素，假设当前front和rear的值分别为8和3，则该队列的长度为( ).

    A.5    B. 6      C.16     D.17

    【答案】C。队列的长度为(rear-front +maxsize) *maxsi ze= (rear-front+21) *21=16.这种情况和front指向当前元素，rear 指向队尾元素的下一个元素的计算是相同的。

18. 若用数组A0..]来实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除-个元素，再加入两个元素后，rear 和front的值分别为( ).

     A.3和4    B.3和0    C.5和0    D.5和1

    【答案】B。循环队列中，每删除一个元素，队首指针front= (front+1)86，每插入一个元素，队尾指针rear= (rear+1)号6。上述操作后，front=0, rear=3.

20. 利用栈求表达式的值时，设立运算数栈OPEN.假设OPEN只有两个存储单元，则在下列表达式中，不会发生溢出的是( )。

    A. A-B*(C-D)      B. (A-B)*C-D     C. (A-B*C)-D       D. (A-B)*(C-D)

    【答案】B。利用栈求表达式的值时，可以分别设立运算符栈和运算数栈,其原理不变。选项B中A入栈，B入栈，计算得R1, c入栈，计算得R2，D入栈，计算得R3，由此得栈深为2。A、C、D依次.计算得栈深为4、3、3。因此选B。
    
### 判断题
1. 消除递归不一定需要使用栈，此说法（ ）
2. 即使对不含相同元素的同一输入序列进行两组不同的合法的入栈和出栈组合操作，所得的输出序列也一定相同。（ ）
3. 栈与队列是一种特殊操作的线性表。（ ）
4. 若输入序列为 1,2,3,4,5,6,则通过一个栈可以输出序列 3,2,5,6,4,1. （ ）
5. 栈和队列都是限制存取点的线性结构。（ ）
6. 队列是一种插入与删除操作分别在表的两端进行的线性表，是先进后出型结构。（ ）
7. 通常使用队列来处理函数或过程的调用。（ ）
8. 队列逻辑上是一个下端和上端既能增加又能减少的线性表。（ ）
9. 循环队列也存在空间溢出问题。（ ）
10. 栈和队列都是线性表，只是在插入和删除时受到了一些限制。（ ）
11. 栈和队列的存储方式，既可以是顺序方式，又可以是链式方式。（ ）

【答案】 1. 正确 2. 错误 3 正确 4. 正确 5. 正确 6. 错误 7. 错误 8. 正确 9. 正确 10. 正确 11. 正确

### 填空题

1. 链栈(不带头结点)执行Pop操作，并将出栈的元素存在x中，应该执行  (               )，(               ) 。

   【答案】x=top ->data; top=top- >next

2. 向一个栈顶指针为top的链栈(不带头结点)中插入一个x结点，则执行   (               )，(               )。

   【答案】x->next=top; top=x

### 操作题
1. 有5个元素，其入栈次序为A,B,C,D,E, 在各种可能的出栈次序中，第一个出栈元素为C且第二个出栈元素为D的出栈序列有哪几个?

2. 若元素的进栈序列为A,B,C,D,E,运用栈操作，能否得到出栈序列B,C,A,E,D和D, B,A,C,E?为什么?

3. 例设有一个双端队列，输入序列为1, 2,3, 4,试分别求出以下条件的输出序列。

   

(1)能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的输出序列。

(2)能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的输出序列。

(3)既不能由输入受限的双端队列得到，又不能由输出受限的双
