# 串

## 串的定义

串，即字符串(String），是由零个或多个字符组成的有限序列。一般记为其中，s是串名，引号（单/双引号都可）括起来的字符序列是串的值；可以是字母、数字或其他字符；字符下标从1开始，串中字符的个数n称为串的长度。n=0时的串称为空串（用∅表示）。

## 什么是子串

串中任意个连续的字符组成的子序列
* 主串:包含子串的串。
* 字符在主串中的位置: 字符在串中的序号。（注意位序从1开始，而不是0）
* 子串在主串中的位置: 子串的第一个字符在主串中的位置。
* 空串:即n=0；
* 空格串: 空格串即串的值是若干空格字符

### 串和线性表的区别

串是一种特殊的线性表，数据元素之间呈线性关系。

区别：串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等)；

串的基本操作，如增删改查等通常以子串为操作对象。

### 串存储结构的具体实现

存储一个字符串，数据结构包含以下 3 种具体存储结构：
* 定长顺序存储：实际上就是用普通数组（又称静态数组）存储。例如 C 语言使用普通数据存储字符串的代码为 char a[20] = "data.biancheng.net"；
* 堆分配存储：用动态数组存储字符串；
* 块链存储：用链表存储字符串；

## 基本操作

假设有空串T=""，主串S="iPhone 11 Pro Max?”，字串W=“Pro"
```c
StrASSign(&T,charS)//赋值操作。把串T赋值为chars。
StrCopy(&T,S)//复制操作。由串S复制得到串T。
StrEmpty(S)//判空操作。若S为空串，则返回TRUE，否则返回FALSE。
StrLength(S)//求串长。返回串S的元素个数。
ClearString(&S)//清空操作。将S清为空串。
DestroyString(&S)//销毁串。将串S销毁（回收存储空间）。
Concat(&T,S1,S2)//串联接。用T返回由S1和S2联接而成的新串
SubString(&Sub,S,pos,len)//求子串。用Sub返回串S的第pos个字符起长度为len的子串。
Index(S,Sub)//定位操作。若主串S中存在与串Sub值相同的子串，则返回它在主串S中第一次出现的位置;否则函数值为0。
StrCompare(S,T)//比较操作。若S>T，则返回值>O;若S=T，则返回值=0;若S<T，则返回值<O。
Concat要考虑存储空间的问题；StrCompare比较的是字符在计算机中存储的二进制数的大小。
```
## 串的存储结构

存储结构不同，运算的实现方式不同。主要分为顺序存储和链式存储两种。

### 顺序存储的实现

顺序存储基于数组，如同顺序表一样，只不过存储的是字符而不是其他类型的数据。

```c
//静态数组（定长顺序存储） 
#define MAXLEN 255
typedef struct{
	char ch[MAXLEN]; //每个分量存储一个字符 
	int length;      //串的实际长度 
}SString;            //函数结束，系统自动回收 

//动态数组（堆分配存储 ）
typedef struct{
	char *ch;        //ch指向串的基地址 
	int length;      //串的长度 
}HString; 
HString S;
S.ch = (char *)malloc(MAXLEN*sizeof(char)); //malloc申请的空间在堆区（heap）,手动free释放存储空间 
S.length = 0;
```

### 链式存储

顺序存储基于链表，如同链表一样，只不过存储的是字符而不是其他类型的数据。


```c
typedef struct StringNode{
	char ch;        //每个节点存1个字符 1B
	struct StringNode *next;          //4B
}StringNode , *String;                //存储密度低（字符1B+指针4B),可以让每个节点多存些字符
//推荐下面的定义： 
typedef struct StringNode{
	char ch[4];     //每个节点存4个字符 4B
	struct StringNode *next;          //4B
}StringNode , *String; 
```


顺序串和链式串的优缺点结合顺序表和链式表分析

## 字符串的模式匹配算法

### 什么是模式匹配

模式匹配: search功能, 在主串中找到与模式串相同的子串，并返回其所在位置。

主串；模式串（所要找到的子串）

子串:主串的一部分,一定存在；模式串――不一定能在主串中找到

模式匹配的两种算法：朴素模式匹配算法；KMP算法

### 朴素模式匹配算法

思路：（暴力穷举所有子串进行匹配）与前面介绍的Index（S,Sub）思路一致

主串长度为n，模式串长度为m；

朴素模式匹配算法∶将主串中所有长度为m的子串依次与模式串对比（最多对比 n-m+1个子串），直到找到一个完全匹配的子串或所有的子串都不匹配为止。

指针回退的关键：i = i-j+2; j=1;

```c
//S:主串；T:模式串 
int Index(SString S,SString T){
	int i=1,j=1;
	while(i<=S.length && j<=T.length){//对比 S.length-T.length+1次 
		if(S.ch[i] == T.ch[j]){
			++i;++j;//当前字符匹配，对比后继字符 
		}else{//匹配到不相等的字符时，指针回退，重新匹配 
			i = i-j+2;
			j = 1; 
		}
	}
	if(j>T.length)	return i-T.length;//模式串的字符与子串全部匹配
	else return 0; 
}
```
最坏（最后一个子串与模式串匹配）时间复杂度：O(nm) 其中m=模式串长； n=主串长



### KMP算法

#### 算法思想

由D.E.Knuth，J.H.Morris和V.R.Pratt提出，因此称为KMP算法。基于朴素模式匹配算法思想优化而来。

朴素模式匹配算法：需要对比n-m+1个子串；KMP算法：根据对每次匹配时，当前字符之前的字符是已知的，根据这一点，可以跳过一些对比，对朴素模式匹配算法进行优化。

下一次匹配时 i 和 j 要调到什么位置，是该算法要思考的问题。

i 跳到何位置？——next数组/nextval数组（手算next数组/nextval数组）

j 跳到何位置？——主串指针不需要回溯（好马不吃回头草）

### 算法代码实现

无需背诵


```c
int Index_KMP(SString S,SString T,int next[]){
	int i=1,j=1;
	while(i<=S.length && j<=T.length){
		if(S.ch[i]==T.ch[i]|| j==0){
			++i;++j;//比较后续字符 
		}else{
			j = next[j];//模式串的第j个位置不匹配，模式串指针j要根据next数组回溯 
		}
	}
	if(j>T.length) return i-T.length; //匹配成功
	else return 0; 
} 
```

算法复杂度：O(m+n) = 求next数组复杂度O(m) + 最坏匹配复杂度O(n） 

### 求next数组和nextval数组

首先说，next和nextval都包括1和0两种不同模式，其中模式1=模式0+1，模式0=模式1-1。例如next1=next0+1，nextval0=nextval1-1。

其次是，不管是next数组和nextval数组，都是对模式串的分析所得到的结果，与主串无关。在做题的时候，要抓住模式串这一变量。![Screen Shot 2023-12-10 at 20.10.34](./assets/Screen%20Shot%202023-12-10%20at%2020.10.34.png)

#### 求解next1

next1数组的求解方法：**首先第一位的next值直接给0，第二位的next值直接给1，后面求解每一位的next值时，都要前一位进行比较。首先将前一位与其next值的对应位进行比较，若相等，则该位的next值就是前一位的next值加上1；若不等，继续重复这个过程，直到找到相等某一位，将其next值加1即可，如果找到第一位都没有找到，那么该位的next值即为1。**

> 故事助记：「检查作业」—— 这次是几分呢？
> 手里拿个小本，看左边的题目的结果，根据这个结果给出的位置找答案，哦一样的，在这个结果基础上加1分；哦不一样啊，以当前这个结果作为新结果，以新结果给出的位置继续找，重复进行，如果找到了，就在新结果基础上加1分；如果找不到，那就勉强给1分。

举例：

|模式串编号|1|2|3|4|5|6|7|8|
|----|----|----|----|----|----|----|----|----|
|模式串|a|b|a|a|b|c|a|c|
|next1|0|1|1|2|2|3|1|2|
|next0|-1|0|0|1|1|2|0|1|

#### 求解next0

在next1的基础上，值全部-1

#### next1数组求解示例

#### 具体求解步骤

1. 前两位必为0，1。
2. 计算第三位的时候，看第二位b的next值，为1，则把b和1对应的a进行比较，不同，则第三位a的next的值为1，因为一直比到最前一位，都没有发生比较相同的现象。
3. 计算第四位的时候，看第三位a的next值，为1，则把a和1对应的a进行比较，相同，则第四位a的next的值为第三位a的next值加上1，为2。因为是在第三位实现了其next值对应的值与第三位的值相同。
4. 计算第五位的时候，看第四位a的next值，为2，则把a和2对应的b进行比较，不同，则再将b对应的next值1对应的a与第四位的a进行比较，相同，则第五位的next值为第二位b的next值加上1，为2。因为是在第二位实现了其next值对应的值与第四位的值相同。
5. 计算第六位的时候，看第五位b的next值，为2，则把b和2对应的b进行比较，相同，则第六位c的next值为第五位b的next值加上1，为3，因为是在第五位实现了其next值对应的值与第五位相同。
6. 计算第七位的时候，看第六位c的next值，为3，则把c和3对应的a进行比较，不同，则再把第3位a的next值1对应的a与第六位c比较，仍然不同，则第七位的next值为1。
7. 计算第八位的时候，看第七位a的next值，为1，则把a和1对应的a进行比较，相同，则第八位c的next值为第七位a的next值加上1，为2，因为是在第七位和实现了其next值对应的值与第七位相同。

#### 另一种解法

先求模式串S 每一个字符前面的那个字符串的最大公共前后缀长度，将这一系列长度存成一个数组，求出来的每个长度其实就是和模式串每一个对应位置上做比较的下标。

例如：模式串是`ABACABC`，其最长公共前后缀长度数组为：我们将最长公共前后缀长度记作`LCPSF`，现在从模式串第一个字符A开始，A的前面字符串为null，所以A之前的子串的`LCPSF`是0；来到B，B的前面字符串是A，A是单独的字符不存在公共前后缀，所以长度也是0；来到A，A前面的子串是AB，`LCPSF`为0；来到C，C前面的子串是ABA，`LCPSF`为1；来到A，A前面的子串是ABAC，`LCPSF`为0；来到B，B之前子串为ABACA，`LCPSF`为1；来到C，C前面子串为ABACAB，`LCPSF`为2；到此这个最长公共前后缀数组就出来了`[0,0,0,1,0,1,2]`将这个数组从第二个值开始每个值加1后，得到`[0,1,1,2,1,2,3]` 就是将要和子串对应位置比较的下标，即为next数组。

------

#### 求解nextval数组

掌握了上面求next数组的方法后，我们可以迅速求得模式串ABACABC的next数组为[0,1,1,2,1,2,3]，现在继续求模式串ABACABC的next-val数组：

**求解nextval数组是基于next数组的，模式串每一个位置的字符和其next数组值给出的下标的对应位置的数作比较，相等就取next-val中对应的next数组值作为当前位置字符的next-val值，不等就直接取当前位置字符的next数组的值作为next-val的值。**

> 故事助记：（nextval数组第一位始终是0，从第二位开始）妈妈都会告诉小朋友不要相信陌生人，确定nextval数组的问题就可以抽象为要不要拿别人东西吃的问题，每个小朋友心里都有自己想吃的东西（当前位置数组项），并且每位小朋友手里都有一个线索（next数组项对应每位小朋友手里的线索），当别人给自己东西吃的，就拿自己线索对应的别人的吃的东西做比较，如果线索对应的东西不是自己爱吃的，那就选择吃自己的东西（保留自己的线索），否则就吃别人的东西（把别人的线索拿过来）。

**求解步骤：**

1. next-val数组第1位：0
2. next-val数组第2位：模式串第二个字符为B，对应的下标数组第二个数是1，那就是将模式串的第1个字符和B相比较，A!=B,所以直接将下标数组第二个数1作为next-val数组第二个数的值
3. next-val数组第3位：模式串第三个字符为A，对应下标数组第三个数为1，取其作为下标，找到模式串第1个字符为A，A=A，那取next-val的第一个数做为next-val第三个数的值，也就是0
4. next-val数组第n位：按照第3位计算方式计算

**举例：**

| 位置         |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :----------- | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 模式串       |  A   |  B   |  A   |  C   |  A   |  B   |  C   |
| next1数组    |  0   |  1   |  1   |  2   |  1   |  2   |  3   |
| Nextval1数组 |  0   |  1   |  0   |  2   |  0   |  1   |  3   |

> 注意，这里所有序号，第一个位置都是1开始

#### next 和 nextval 比较

next数组的缺陷举例如下：比如主串是"aabXXXXXXXXXXXXXX"，模式串"aac"，通过计算 "aac" 的next数组为012，当模式串在字符c上失配时，会跳到第2个字符，然后再和主串当前失配的字符重新比较，即此处用模式串的第二个a和主串的b比较，即"aabXXXXXXXXXXXXXX"vs"aac"，显然a也不等于b。然后会跳到1接着比，直到匹配成功或者匹配失败主串后移一位。而"aac"的nextval数组为002 当在c失配时会跳到2，若还失配就直接跳到0，比next数组少比较了1次。在如果模式串很长的话，那可以省去很多比较，因此使用nextval数组比next数组高效。

####  问题思考

在模式匹配的KMP算法中，求模式的next数组值（也称为KMP算法中失败函数）定义如下：

+ 当j=1时，为什么要取next[1]=0?
   答：当模式串第一个字符与主串中某字符不匹配时，主串指针应移至下一字符，再和模式串第一个字符比较。（next[1]=0 表示模式串中已没有字符可与主串中当前字符 s[i] 比较）
+ 为什么要取 max{k}，k最大是多少？
   答：当主串中第 i 个字符与模式串中第 j 个字符不匹配时，若主串 i 不回溯，则假定模式串中第 k 个字符与主串中第 i 个字符比较，k 值应满足条件 1<k<j，并且 'p1...pk-1' == 'pj-k+1...pj-1'，即模式串向后移动的距离为 k，k值可能有多个，为了不使移动产生丢失可能的匹配，k要取最大值，max{k}表示移动的最大的距离，k的最大值为 j-1。
+ 其它情况是什么？为什么取 next[j] = 1?
   答：以上两种情况的不匹配，主串指针不回溯，在最坏的情况下，模式串从第 1 个字符开始与主串第 i 个字符比较，以便不丢失可能的匹配。



## 习题

### 选择

1. 已知字符串s 为"abaabaabacacaabaabcc", 模式串t 为“abaabc”,  采用KMP 算法进行匹配，第 一次出现“失配”(s[1!=t[i])   时 ，i=j=5, 则下次开始匹配时，i 和j 的值分别是(   )。

   A.i=1,j=0            B.i=5,j=0**            C.i=5,j=2             D.i=6,j=2

2. 下面关于串的叙述中，哪一个是不正确的?(  )

   A. 串是字符的有限序列          B. 空串是由空格构成的串

   C.  模式匹配是串的一种重要运算      D. 串既可以采用顺序存储，也可以采用链式存储

3. 若 串S₁=ABCDEFG,S2=9898,S3=###,S4=012345',   执行 concat(replace(S1,substr(S1,length(S2),length(S3)),S3),substr(S4,index(S2,'8),length(S2))),    其结果为(  )。

   A.ABC###G0123     B.ABCD###2345      C.ABC###G2345      D.ABC###2345

   E.ABC###G1234     F.ABCD###1234      G.ABC###01234

4. 设有两个串S1 和 S2, 求 S2 在 S1 中首次出现的位置的运算称作(   )。

   A. 求子串      B. 判断是否相等   C.  模型匹配     D. 连接

5. 已知串S='aaab',  其 Next 数组值为(  )。

   A.0123      B.1123      C.123]       D.1211

6. 串'ababaaababaa'的 next 数组为(   )。

   A.012345678999   B.012121111212    C.011234223456   D.012301232234

7. 字符串'ababaabab'的nextval  为(   )。

   A.(0,1,0,1,0,4,1,0,1)                        B.(0,1,0,1,0,2,1,0,1)

   C.(0,1,0,1,0,0,0,1,1)                        D.(0,1,0,1,0,1,0,1,1)

8. 模式串t=abcaabbcabcaabdab', 该模式串的next 数组的值为(   ),nextval数组的值为(   )。

   A.01112211123456712        B.01112121123456112

   C.01110013101100701        D.01112231123456712

   E.01100111011001701    F.01102131011021701

9. 若串 S="myself", 其子串的数目是(  )。
   A.20        B.21         C.22         D.23

10. 若串S=software',  其子串的数目是(  )。
    A.8                B.37        C.36       D.9

11. 设 S 为一个长度为n 的字符串，其中的字符各不相同，则S 中的互异的非平凡子串(非空且不同于S 本身)的个数为(  )。

    A.2n-1            B.n2                 C.(n2/2)+(n/2)         D.(n2/2)+(n/2)-1
    E.(n2/2)-(n/2)-1        F.其他情况

12. 串是一种特殊的线性表，其特殊性体现在(  )。
    A.  可以顺序存储             B. 数据元素是一个字符
    C. 可以链接存储             D. 数据元素可以是多个字符

13. 在下列表述中，(  )是错误的。

    A. 含有一个或多个空格字符的串称为空格串
    B. 对 n(n>0)个顶点的网，求出权最小的n-1 条边便可构成其最小生成树
    C. 选择排序算法是不稳定的
    D. 平衡二叉树的左右子树的结点数之差的绝对值不超过1

### 编程题

1. 设 s、t为两个字符串，分别放在两个一维数组中， m、n 分别为其长度，判断t是否为s 的子 串。如果是，输出子串所在位置(第一个字符),否则输出0。

2. 输入一个字符串，内有数字和非数字字符，如： ak123x45617960?302gef4563, 将其中连续 的数字作为一个整体，依次存放到一数组a 中，例如123放入a[0],456 放入a[1],……编程统计其共有多少个整数，并输出这些数。

3. 以顺序存储结构表示串，设计算法。求串S 中出现的第一个最长重复子串及其位置并分析算 法的时间复杂度。

4. 假设串的存储结构如下(略),编写算法实现串的置换操作。

5. 函数 void  insert(char*s,char*t,int  pos)将字符串t 插入字符串s 中，插入位置为pos。请用C 语言实现该函数。假设分配给字符串s 的空间足够让字符串t 插入。(说明：不得使用任何库 函数。)

6. 设计一个二分检索的算法，在一组字符串中找出给定的字符串，假设所有字符串的长度为4。 (1)简述算法的主要思想； (3分) 
    (2)用Pascal 语言分别对算法中用到的类型和变量作出说明；  
    (3)用类 Pascal 语言或自然语言写算法的非递归过程；  
    (4)分析该算法的最大检索长度；   
    (5)必要处加上中文注释。 
    
    

## 答案

| 1.C  | 2.B  | 3.E  | 4.C   | 5.A  | 6.C  | 7.A  | 8.1D | 8.2F | 9.C  |
| ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| 10.B | 11.D | 12.B | 13.BD |      |      |      |      |      |      |


1. 判断字符串t是否是字符串s 的子串，称为串的模式匹配，其基本思想是对串s 和t各设一 个指针i和j,i 的值域是0.m-n,j 的值域是0.n-1。初始值i和j 均为0。模式匹配从s₀ 和 t₀开始，若so=t₀, 则i 和j 指针增加1,若在某个位置s!=t,   则主串指针i 回溯到i=i-j+1,j 仍从0开始，进行下一轮的比较，直到匹配成功 (j>n-1),  返回子串在主串的位置 (i-j)。否 则 ， 当i>m-n  则为匹配失败。核心语句段如下：

```
while(i<=m-n &&j<=n-1)              //初值i=0,j=0;    主串s,  子 串t,m  和 n 分别是其长度
if(s[i]==t[j]){i++;j++;}              //对应字符相等，指针后移
else   {i=i-j+1;j=0;}            //对应字符不相等， i 回溯， j  仍为0
if(i<=m-n    &&j==n){cout<<"t串在s 串中位置："<<i-n+1;}//  匹配成功
else  return(0);                    //匹配失败
```





