# 线性表

## 什么是线性表

线性表(linear list)是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。

线性表中数据元素之间的关系是一对一的关系, 即除了第一个和最后一个数据元素之外, 其它数据元素都是首尾相接的(注意, 这句话只适用大部分线性表, 而不是全部)。比如, 循环链表一种线性表 (把最后一个数据元素的尾指针指向了首位结点，做题时若有问如：循环队列、循环链表为什么结构，为物理结构而非逻辑结构)。

使用线性表表示数据的方式可以这样理解, 即「把所有数据用一根线串起来, 再存储到物理空间中」。线性表的标准定义是由n(≥0)个数据元素(结点)组成的有限序列, 用数学表达式来定义线性表：如果线性表表示为数据元素(a1,a2,…,an)组成的有限序列, 那么该序列中的所有结点具有相同的数据类型。

## 线性表的基本特点

​	结合前文所述，其基本特点有：

1. 线性表强调元素具有相同的数据类型。
2. 元素的下标表示该元素在线性表中的位置, 但这个位置仅仅表示元素的先后关系, 并不表示元素之间的大小关系。
3. 除了第一个元素和最后一个元素之外, 每个数据元素都有唯一的前驱和后继元素。

## 线性表的主要存储结构

线性表的存储结构可细分为顺序存储结构和链式存储结构

+ 将数据依次存储在连续的整块物理空间中, 这种存储结构称为顺序存储结构(简称顺序表)。
+ 数据分散的存储在物理空间中, 通过一根线保存着它们之间的逻辑关系, 这种存储结构称为链式存储结构(简称链表)。

### 顺序存储结构

特点：
1. 结点中只有自身的信息域, 没有关联信息域。因此, 顺序存储结构的存储密度大度、存储空间利用率高。
2. 通过计算地址直接访问任何数据元素, 即可以随机访问。
3. 插入和删除操作会引起大量元素的移动。

如图2-1:  
| ![图2-1](./assets/T001.png) |
| :-------------------------: |
|            图2-1            |

### 顺序表的随机存取

我们简单讲了顺序结构在内存中占有连续的地址空间,顺序表具有随机访问能力。例如,有线性表(1, 10, 30, 4, 15, 26, 27), 假设数据元素都是整数(int 类型的数据), 每个整数占有4字节的空间,这个顺序表在内存中的结构如下表所示, 
|数组|1|10|30|4|15|26|27|
|----|----|----|----|----|----|----|----|
|下标|0|1|2|3|4|5|6|
|元素大小|4B|4B|4B|4B|4B|4B|4B|

当把这个顺序表存储在内存中时, 每个数据元素要有一个位置(编号),这个编号成为内存地址(指针)(可以参考C语言基础中关于内存的讲解部分), 逻辑上相邻的数据元素在位置上也相邻, 如数据元素 1和数据元素 10 的地址相差4B。假如给定数据元素 1 在内存中的地址是 100,则数据元素 10 的地址就是104(100+1×4),数据元素 30 的地址是 108(100+2×4), 以此类推后续数据元素的地址。

推广到一般情况, 假设线性表在内存中存储时, 每个元素占用L个存储空问, 则相邻两个元素在内存中的存储地址相差L, 如果已知第一个元素的内存地址, 只要给出位置下标, 就可以利用上述公式计算得出该位置的地址。结合第一讲中的时间复杂度的概念, 不管数据元素在哪个位置, 只要给出下标i.都可以读取或更新该元素的值。这个特点就是随机访问, 记住一点：只要是顺序结构, 都具备这个特点。

举个例子：如若有 int A[10];  我们会认为数组A是能够随机存取的，能这样说的根本原因就是因为可以直接按上文所说的计算得出A[i]的地址，如i=2时，A[i]地址为A[0]的地址 + 2*sizeof（A[0]）	(A[0]的地址在int A[10]以后就被系统给出,其中相邻两个元素在内存中存储地址相差的L通常可以用sizeof(A[0])来得到)。

### 程序操作

#### 顺序表的查找

查找数据元素在表中的位置, 可以从表头开始一直遍历表中元素。如果找到与要查找元素e相等的元素, 就返回元素在表中的位置, 由于数组下标从0开始, 则元素在表中对应的位置序号值应为对应数组。

查找顺序表中第i个元素的值(按序号查找), 如果找到, 将将该元素值赋给e。查找第i个元素的值时, 首先要判断查找的序号是否合法, 如果合法, 返回第i个元素对应的值。

```c
int GetData(PSeqList L, int i)
{
    if (L->length < 1 || (L->length > LengthList(L)))
    {
        return 0;
    }
    //数据元素的序号从1开始, 数组下表从0开始, 第i个元素对应的数组下标为i-1;
    return L->data[i - 1];
}
```
#### 顺序表的插入
在数据表的第i个位置插入元素, 在顺序表的第i个位置插入元素e, 首先将顺序表第i个位置的元素依次向后移动一个位置, 然后将元素e插入第i个位置, 移动元素要从后往前移动元素, 即：先移动最后一个元素, 在移动倒数第二个元素, 依次类推；插入元素之前要判断插入的位置是否合法, 顺序表是否已满, 在插入元素之后要将表长L->length++;

在顺序表L=(a1, a2, a3 ... an)中的第i(1<i<n)个位置上插入一个新结点e，实现步骤如下。
1. 将线性表中的第i个至第n个结点后移一个位置（需要先从最后一个元素开始移动）。
2. 将结点e插人到结点a-1之后。
3. 线性表长度加1。

例如图2-1中在第二个元素后面加入元素27, 则存储空间变为如图2-2所示

| ![Teacher](./assets/Teacher.png) |
| :------------------------------: |
|              图2-2               |

```c
int InsList(PSeqList L, int i, DataType e)
{
 
    //判断插入位置是否合法
    if (i < 1 || L->length >(LengthList(L) + 1))
    {
        printf("插入位置不合法!\n");
        return 0;
    }
    //判断顺序表是否已满
    else if (L->length >= ListSize)
    {
        printf("顺序表已满, 不能插入！\n");
        return 0;
    }
    else
    {
        for (k = i; k <= L->length; k--)
        {
            L->data[k + 1] = L->data[k];
        }
        L->data[i - 1] = e;
        L->length++;   //数据表的长度加1
        return 1;
    }
    return 0;
}
```
#### 顺序表的删除

1. 取出删除元素。
2. 从删除元素位置开始遍历到最后一个元素位置, 分别将它们都向前移一个位置。
3. 线性表表长-1。

例如图2-1删除元素4, 则存储空间变为如图2-所示

对于2的理解我们常可以认为，因为顺序表的特性是除第一个和最后一个外的元素都需要有前驱和后继，倘若不进行2操作将他们往前移一个位置，将会破坏顺序表的这一特性。

|![](./imgs/2-3.png)|
|:-:|
|图2-3|

```c
//初始条件：顺序线性表L已经存在, 1<=i<=ListLength(L)
//操作结果：删除L的第i个元素, 并用e返回其值, L长度-1
Status ListDelete(SqList *L,int i,ElemType e)
{
    int k;
    if(L->length==0)//判断表长是否为空
    {
        return error;
    }
    if(i<1 || i>L->length)//删除位置是否正确
    {
        return error;
    }
 
    *e=L->data[i-1];//返回删除的值
 
    if(i<L->length)
 
    {
        //将要插入位置后的数据元素向前移一位
 
        for(k=i;k<L->length;k++)
        {
            L->data[k-1]=L->data[k];
        }
    }
   
    L->length--;//线性表表长-1
 
    return ok;
}
```

#### 获取顺序表的长度

顺序表的长度就是就顺序表中的元素的个数, 由于在插入和删除操作中都有对数据表的长度进行修改, 所以求表长只需返回length的值即可。

例如图2-1中的线性表，长度为5。

```c
int LengthList(PSeqList L)
{
    if (L == NULL)
    {
        return 0;
    }
    return L->length;
}
```

### 链式存储结构

链表是一种物理存储单位上非连续非顺序的存储结构, 数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

特点:
+ 结点除自身的信息域外, 还有表示关联信息的指针域。因此, 链式存储结构的存储结构小、存储空间利用率低。
+ 在逻辑上相邻的结点在物理上不必相邻, 因此, 不可以随机存取, 只能顺序存取。
+ 插入和删除操作方便灵活, 不必移动结点只需修改结点中的指针域即可。

单链表:线性表的链接存储结构, 用一组任意(不联系, 零散分布) 的存储单元存放线性表的元素.      
单链表是由若干结点构成的, 结点包含数据域和指针域。

```mermaid
graph LR
head-->a0
a0-->a1
a1-->a2
a2-->a3
a3-->NULL
```



### 链表的操作

#### 定义

data: 存储数据元素  
next: 存储指向后继结点的地址 

```c
// 定义节点
typedef struct node
{
    int data;              //数据域
    struct node *next;     //指针域
}Node,*Link;               //定义别名 Node, Link
```
#### 遍历操作

```c
void displayNode(Link head)
{
    Link p = head->next;          //p指向首元结点
    while(p != NULL)
    {
        printf("%d\t",p->data);  //输出数据 
        p = p->next;             //移向下一个结点
    }
}
```
#### 求链表长度

1. p初始化, 累加器count初始化
2. 重复执行下述操作, 直到p为空;
3. 工作指针p后移
4. count++
5. 循环结束，返回累加器count的值

上图中, 链表长度为4, a3指向的NULL并非真实存在

```c
int length(Link head)
{
    int count = 0;
    Link p = head->next;
    while(p != NULL)
    {
        p = p->next;
        count++;
    }
    return count;
}

```

#### 链表查找

操作接口:bool queryNode(Link head, int x);

思路: 依次遍历链表的数据域与要查找的数据进行比较。直到找到为止。当然如果找不到也不能强求，返回`false`就好了

例如：

```mermaid
graph LR
head-->0
0-->7
7-->9
9-->3
3-->NULL
```

在这样的链表中，可以通过遍历找到9，但是如果想找到21是不可能的。

```c
bool queryNode(Link head, int x)
{
    Link p = head->next;
    while(p != NULL)
    {
        if(p->data == x) //查找成功
        {
            printf("d",p->data);
            return true;
        }
        p = p->next;   //没有找到,移动结点
    }
    return false;     //查找失败返回false
}
```
#### 链表插入

操作接口:bool insertNode(Link head, int index, int item);

插入到第i个结点, 先找到第i-1个节点, 然后, 让插入结点的指针域指向i-1个结点的指向的指针域, 再修改第i-1结点的指针域, 使其指向插入结点. 注意, 修改指针指向的顺序不要颠倒, 不然会导致找不到第i个结点. 对于边界情况也同样适合.

1. 工作指针p初始化
2. 查找第i-1个结点, 并使该指针p指向该结点
3. 若查找不成功,则返回false
    否则:
    生成一个元素值为x的新结点node
    将新结点插入到p所指向的结点
    返回true

例如在a2后面插入a9

```mermaid
graph LR
head-->a0
a0-->a1
a1-->a2
a2-->a9
a9-->a3

a3-->NULL
```

```c
bool insertNode(Link head, int index, int item)
{
	int count=0;
    Link p = head;
    Link node;
    while(p != NULL && count < index-1)   //找到第index前一个结点
    {
        p = p->next;
        count++;
    }
    if(p == NULL)
    {
        return false;                    //没有找到第i-1个结点
    }
    else
    {
        node = (Link)malloc(sizeof(Node));//申请一个结点
        node->data = item;                //结点的数据域
        node->next = p->next;             //①修改指针指向关系
        p->next = node;					  //②
        return true;
    }
}
```
  需要注意的是，代码注释中标注了①，②的顺序（即修改指针指向关系的步骤）切记不能搞反



#### 链表删除节点

操作接口: bool deleteNode(Link head,DateType x);思路:
引入两个指针p,q, p指向要删除的结点, q指向要删除结点的前一个结点

找到要删除的结点, 用free()函数释放该节点, 并修改删除结点两边指针关系情况,
要保证p,q指针一前一后: 在插在过程中, 若发现结点p指向的数据域不等于x, 则p,q指针同时向前移动即可

若在查找过程一直没有找到要删除的结点(链表遍历完毕),则退出循环,返回错误。

例如，上图中删除a2的结果为

```mermaid
graph LR
head-->a0
a0-->a1
a1-->a3
a3-->NULL
```

### 线性表的其他存储结构

单链表或静态链表每次从头开始访问, 如果想从任意位置开始访问, 那么使用单链表或静态链表就比较难做到。如果想直接找前驱, 那么使用单链表或静态链表也是很难实现的。所以我们使用如下的数据结构
#### 循环单链表

在单链表的基础上, 设计了一种「循环性」单向链表,称为「单向循环链表」。相比于单向链表, 单向循环链表的最大特点是「尾结点的指针域指向头结点『, 可以从任何位置出发访问单链表,如图:  

```mermaid
graph LR
head-->a0
a0-->a1 
a1-->a2
a2-->a3
a3-->a4
a4-->a5
a5-->a6
a6-->a7
a7-->a0
```




在考研中, 循环单链表的操作和单链表相同, 只需要记住两个特殊的知识点。

1. 当单链表为空时,head->next == head.
2. 当结点是表尾结点时, p->next == head.
#### 双向链表

双向链表是链表的一种, 是指构成链表的每个结点中设立两个指针域：一个指向其直接前驱的指针域, 另外一个指向后继的指针域。如图: 

```mermaid
graph LR

CMP[HEAD]
a0((a0))
a1((a1))
ao((...))
an((an))
CMP---a0
a0-->a1
a1-->a0
a1-->ao
ao-->a1
an-->ao
ao-->an
an-->NULL

```

#### 双向循环链表

双循环向链表结合了双链表和循环链表的特点，即有两个指针域，又能够循环，所以循环双链表往往是功能最强大的。

```mermaid
graph LR

CMP[HEAD]
a0((a0))
a1((a1))
ao((...))
an((an))
CMP---a0
a0-->a1
a1-->a0
a1-->ao
ao-->a1
an-->ao
ao-->an
an-->a0

```


### 静态链表

静态链表, 也是线性存储结构的一种, 它兼顾了顺序表和链表的优点于一身, 可以看做是顺序表和链表的升级版。使用静态链表存储数据, 数据全部存储在数组中(和顺序表一样), 但存储位置是随机的, 数据之间"一对一"的逻辑关系通过一个整形变量(称为"游标", 和指针功能类似)维持(和链表类似)。

例如, 使用静态链表存储 {1,2,3} 的过程如下：

创建一个足够大的数组, 假设大小为6, 如图所示：


|![./imgs/2-17.png](./imgs/2-17.png)|![./imgs/2-19.png](./imgs/2-19.png)|
|:-:|:-:|
|图2-11 空数组|图2-12 静态链表存储数据|

接着, 在将数据存放到数组中时, 给各个数据元素配备一个整形变量, 此变量用于指明各个元素的直接后继元素所在数组中的位置下标, 如图所示：  


通常, 静态链表会将第一个数据元素放到数组下标为 1 的位置(a[1])中。

上图中, 从 a[1] 存储的数据元素 1 开始, 通过存储的游标变量 3, 就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样, 通过元素 a[3] 存储的游标变量 5, 可以在 a[5] 中找到元素 2 的直接后继元素 3, 这样的循环过程直到某元素的游标变量为 0 截止(因为 a[0] 默认不存储数据元素)。

类似这样, 通过 "数组+游标" 的方式存储具有线性关系数据的存储结构就是静态链表。
静态链表中的节点

通过上面的学习我们知道, 静态链表存储数据元素也需要自定义数据类型, 至少需要包含以下 2 部分信息：
+ 数据域：用于存储数据元素的值；
+ 游标：其实就是数组下标, 表示直接后继元素所在数组中的位置；

因此, 静态链表中节点的构成用 C 语言实现为：

```c

typedef struct {
    int data;//数据域
    int cur;//游标
}component;

```

#### 备用链表

上图的静态链表还不够完整, 静态链表中, 除了数据本身通过游标组成的链表外, 还需要有一条连接各个空闲位置的链表, 称为备用链表。

备用链表的作用是回收数组中未使用或之前使用过(目前未使用)的存储空间, 留待后期使用。也就是说, 静态链表使用数组申请的物理空间中, 存有两个链表, 一条连接数据, 另一条连接数组中未使用的空间。通常, 备用链表的表头位于数组下标为 0(a[0]) 的位置, 而数据链表的表头位于数组下标为 1(a[1])的位置。

静态链表中设置备用链表的好处是, 可以清楚地知道数组中是否有空闲位置, 以便数据链表添加新数据时使用。比如, 若静态链表中数组下标为 0 的位置上存有数据, 则证明数组已满。

例如, 使用静态链表存储 {1,2,3}, 假设使用长度为 6 的数组 a, 则存储状态可能如图 3 所示： 

|![备用链表和数据链表](./assets/2-1Q1260S02X93.gif) |![./imgs/2-17.png](./assets/2-14.png) |
|:-:|:-:|
|图2-13 备用链表和数据链表|图2-14 未存储数据之前静态链表的状态|

#### 备用链表和数据链表

图 2-13 中, 备用链表上连接的依次是 a[0]、a[2] 和 a[4], 而数据链表上连接的依次是 a[1]、a[3] 和 a[5]。

#### 静态链表的实现

假设使用静态链表(数组长度为 6)存储 {1,2,3}, 则需经历以下几个阶段。

在数据链表未初始化之前, 数组中所有位置都处于空闲状态, 因此都应被链接在备用链表上, 如下图2-16所示：  

当向静态链表中添加数据时, 需提前从备用链表中摘除节点, 以供新数据使用。
备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样, 向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点, 我们知道它的位置, 操作它的直接后继节点相对容易, 无需遍历备用链表, 耗费的时间复杂度为 O(1)。

因此, 在基础上, 向静态链表中添加元素 1 的过程如图所示：
|![./imgs/2-17.png](./assets/2-15.png)| ![./imgs/2-16.png](./assets/2-16.png) |
|:-:|:-:|
|图2-16. 静态链表中添加元素 1|图2-17 静态链表中继续添加元素 2|

静态链表中继续添加元素 2  ,在图2-17的基础上, 继续添加元素 3，由此, 静态链表就创建完成了。

![图 7 ](./assets/2-18.png)   


## 概念速背

线性表基本概念：线性表是零个或者多个数据元素的有限序列, 数据元素之间是有顺序的, 数据元素个数是有限的, 数据元素的类型必须相同

线性表的性质    
1. a0 为线性表的第一个元素, 只有一个后继。
2. an 为线性表的最后一个元素, 只有一个前驱。
3. 除 a0 和 an 外的其它元素 ai, 既有前驱, 又有后继。
4. 线性表能够逐项访问和顺序存取。

线性表Operation(操作)  
```c
// 初始化, 建立一个空的线性表L。
InitList(*L);
 
// 若线性表为空, 返回true, 否则返回false
ListEmpty(L);
 
// 将线性表清空
ClearList(*L);
 
// 将线性表L中的第i个位置的元素返回给e
GetElem(L, i, *e);
判断线性表是否合法
判断位置是否合法
直接通过数组下标的方式获取元素
 
// 在线性表L中的第i个位置插入新元素e
ListInsert(*L, i, e);
插入元素算法
判断线性表是否合法
判断插入位置是否合法
判断空间是否满足
把最后一个元素到插入位置的元素后移一个位置
将新元素插入
线性表长度加1
 
// 删除线性表L中的第i个位置元素, 并用e返回其值
ListDelete(*L, i, *e);
判断线性表是否合法
判断删除位置是否合法
将元素取出
将删除位置后的元素分别向前移动一个位置
线性表长度减1
 
// 返回线性表L的元素个数
ListLength(L);
 
// 销毁线性表
DestroyList(*L);
 
```
线性表的存储

通常线性表可以采用顺序存储和链式存储。

线性表采用顺序存储的优点和缺点
       优点：
				无需为线性表中的逻辑关系增加额外的空间。
				可以快速的获取表中合法位置的元素。

​		缺点：
​				插入和删除操作需要移动大量元素

为什么要引入线性表的链式存储(单向链表)?  
		前面我们写的线性表的顺序存储(动态数组)的案例, 最大的缺点是插入和删除时需要移动大量元素, 这显然需要耗费时间, 能不能想办法解决呢？链表。
	链表为了表示每个数据元素与其直接后继元素之间的逻辑关系, 每个元素除了存储本身的信息外, 还需要存储指示其直接后继的信息。

单链表的定义  
		线性表的链式存储结构中, 每个节点中只包含一个指针域, 这样的链表叫单链表。通过每个节点的指针域将线性表的数据元素按其逻辑次序链接在一起。

单链表的概念解释  
	表头结点
			链表中的第一个结点, 包含指向第一个数据元素的指针以及链表自身的一些信息。

​	数据结点
​			链表中代表数据元素的结点, 包含指向下一个数据元素的指针和数据元素的信息。

​	尾结点
​			链表中的最后一个数据结点, 其下一元素指针为空, 表示无后继。

​	单链表的相关操作有哪些?
​			和上面的顺序表操作思路一样, 参考上面的就好了。

​	单链表的优点和缺点是什么?
​		优点：
​				无需一次性指定链表的容量
​				插入和删除操作无需移动数据元素  
​		缺点：
​				除了要存储数据元素本身, 还有要存储数据元素之间的逻辑关系
​				获取指定数据的元素需要顺序访问之前的元素



问：双向链表的原理
	双向链表(double linkedlist)是在单链表的每个结点中, 再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域, 一个指向直接后继, 另一个指向直接前驱。



## 习题

### 选择

